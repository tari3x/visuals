<!doctype html>
<html>
  <head>
    
    <title>Yo</title>
    
    <meta charset="utf-8">
    
    <style media="screen">
      * { margin: 0; padding: 0; }
      body, html {
          width: 100%;
          height:100%;
          background: black;
      }
      #video {
          position: absolute;
          /* CR: no visible: false? */
          top: -1000px; 
          cursor: crosshair;
      }
      #canvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 100;
      }
    </style>
  </head>
  <body>
    
    <video id="video" width="960" height="720" preload autoplay loop muted controls></video>
    <canvas id="canvas" width="100%" height="100%" onClick="setMarker(event)" onResize="resize()"></canvas>
    
    <script src="math.min.js"></script>
    
    <script>
      math.config({
        matrix: 'array'       // Choose 'matrix' (default) or 'array'
      });

      var M = math.eye(3);

      var video = document.getElementById("video");
      
      var markers = []

      // CR: this rescales the video image such that clicking on it gives wrong coordinates.
      resize = function() {
        canvas = document.getElementById("canvas");
        context = canvas.getContext('2d');
        
        var width = canvas.offsetWidth;
        var height = canvas.offsetHeight;
        // create a temporary canvas obj to cache the pixel data //
        var temp_cnvs = document.createElement('canvas');
        var temp_cntx = temp_cnvs.getContext('2d');
        // set it to the new width & height and draw the current canvas data into it // 
        temp_cnvs.width = width; 
        temp_cnvs.height = height;
        temp_cntx.drawImage(canvas, 0, 0);
        // resize & clear the original canvas and copy back in the cached pixel data //
        // this clears the drawing
        canvas.width  = width;
        canvas.height = height;
        context.drawImage(temp_cnvs, 0, 0);
      };

      fillAll = function(ctx, background){
        var width = context.canvas.clientWidth;
        var height = context.canvas.clientHeight;
        ctx.fillStyle = background; 
        ctx.fillRect(0, 0, width, height);
      };
      
      setMarker = function(event){
        // push adds at the end
        markers.push([event.offsetX, event.offsetY, 1]);
        console.log(markers.toString());
      };

      transform = function(p) {
        var p = math.multiply([p[0], p[1], 1], M);
        p = math.divide(p, p[2]);
        return p.slice(0, 2);
      }
      
      plotPoint = function(ctx, p, radius){
        var p = transform(p);
        ctx.beginPath();
        ctx.arc(p[0], p[1], radius, 0, 2 * Math.PI, false);
        ctx.fill();
        ctx.beginPath();
      };

      function getFrame(video, context, callback) {
        var width = context.canvas.clientWidth;
        var height = context.canvas.clientHeight;

        setTimeout(
          function(){
            window.requestAnimationFrame(function() {
              context.clearRect(0, 0, width, height);
              if (video.readyState === video.HAVE_ENOUGH_DATA) {
                context.drawImage(video, 0, 0, video.width, video.height);
                callback();
              }
              else getFrame(video, context, callback);
            });
          },
          100);
      };
      
      calibrate = function(video, ctx, callback){
        // zero is top-left corner
        var v0 = [400, 200, 1];
        var v1 = [400, 400, 1];
        var v2 = [600, 200, 1];
        var v3 = [600, 400, 1];

        fillAll(ctx, 'black');

        ctx.fillStyle = 'white';

        plotPoint(ctx, v0, 1);
        plotPoint(ctx, v1, 1);
        plotPoint(ctx, v2, 1);
        plotPoint(ctx, v3, 1);

        function waitForMarkers() {
          if (markers.length < 4) {
            setTimeout(waitForMarkers, 100);
          } else {
            var u0 = markers[0];
            var u1 = markers[1];
            var u2 = markers[2];
            var u3 = markers[3];

            plotPoint(ctx, [0, 0], 5);
            plotPoint(ctx, [10, 20], 5);
            
            plotPoint(ctx, u0, 5);
            plotPoint(ctx, u1, 5);
            plotPoint(ctx, u2, 5);
            plotPoint(ctx, u3, 5);
            
            // "Fundamentals of Texture Mapping and Image Warping",
            // "Inferring Projective Mappings"
            var A =
              [ [ v0[0], v0[1], 1, 0, 0, 0, -v0[0] * u0[0], -v0[1] * u0[0] ],
                [ v1[0], v1[1], 1, 0, 0, 0, -v1[0] * u1[0], -v1[1] * u1[0] ],
                [ v2[0], v2[1], 1, 0, 0, 0, -v2[0] * u2[0], -v2[1] * u2[0] ],
                [ v3[0], v3[1], 1, 0, 0, 0, -v3[0] * u3[0], -v3[1] * u3[0] ],
                
                [ 0, 0, 0, v0[0], v0[1], 1, -v0[0] * u0[1], -v0[1] * u0[1] ],
                [ 0, 0, 0, v1[0], v1[1], 1, -v1[0] * u1[1], -v1[1] * u1[1] ],
                [ 0, 0, 0, v2[0], v2[1], 1, -v2[0] * u2[1], -v2[1] * u2[1] ],
                [ 0, 0, 0, v3[0], v3[1], 1, -v3[0] * u3[1], -v3[1] * u3[1] ]
              ];

            console.log(math.format(A));
            
            var b = [ u0[0], u1[0], u2[0], u3[0], u0[1], u1[1], u2[1], u3[1] ];

            var x = math.flatten(math.lusolve(A, b));

            console.log(math.format(x));

            M =
              [ [ x[0], x[3], x[6] ],
                [ x[1], x[4], x[7] ],
                [ x[2], x[5], 1 ]
              ];

            M = math.inv(M);
            
            console.log(math.format(M));

            /* At this point if you replot the markers they map back to themselves in the same order. */

            callback();
          }
        };

        // for debugging
        // waitForMarkers();

        setTimeout(
          function(){
            getFrame(video, ctx, waitForMarkers)
          },
          1000);
      };

      detect = function(ctx){
        var x = 0;
        var y = 0;
        
        var left = undefined;
        var top = undefined;
        var right = undefined;
        var bottom = undefined;
        
        var width = ctx.canvas.clientWidth;
        var height = ctx.canvas.clientHeight;

        // This is a clone
        pixelData = ctx.getImageData(0, 0, width, height);
        
        fillAll(ctx, 'black');

        ctx.fillStyle = 'green';

        for(y = 0; y < pixelData.height; y++){
          for(x = 0; x < pixelData.width; x++){
            index = (x + y * width) * 4;
            red = pixelData.data[index];
            green = pixelData.data[index+1];
            blue = pixelData.data[index+2];
            
            var threshold = 100;

            if(red < threshold && green < threshold && blue < threshold) {
              plotPoint(ctx, [x, y], 1);
            }

            // get pixel's data
            // currently, we're looking at the blue channel only.
            // Since is a B/W photo, all color channels are the same.
            // ideally, we would make work for all channels for color photos.
            
            /*
            // Get the values of the surrounding pixels
            // Color data is stored [r,g,b,a][r,g,b,a]
            // in sequence.
            left = pixelData.data[index-4];
            right = pixelData.data[index+2];
            top = pixelData.data[index-(width*4)];
            bottom = pixelData.data[index+(width*4)];
            
            // Compare it all.
            // (Currently, just the left pixel)
            if(pixel>left+threshold){
              plotPoint(ctx, [x, y], 0.5);
            }
            else if(pixel<left-threshold){
              plotPoint(ctx, [x, y], 0.5);
            }
            else if(pixel>right+threshold){
              plotPoint(ctx, [x, y], 0.5);
            }
            else if(pixel<right-threshold){
              plotPoint(ctx, [x, y], 0.5);
            }
            else if(pixel>top+threshold){
              plotPoint(ctx, [x, y], 0.5);
            }
            else if(pixel<top-threshold){
              plotPoint(ctx, [x, y], 0.5);
            }
            else if(pixel>bottom+threshold){
              plotPoint(ctx, [x, y], 0.5);
            }
            else if(pixel<bottom-threshold){
              plotPoint(ctx, [x, y], 0.5);
            }
            */
          }
        }
      };

      draw = function(ctx){
        fillAll(ctx, 'black');
        ctx.fillStyle = 'green';
        ctx.fillRect(300, 300, 200, 200);
      };
      
      snapAndDetect = function(ctx){
        console.log("snapAndDetect");
        console.log(ctx);
        fillAll(ctx, 'white');
        setTimeout(
          function(){
            getFrame(
              video, ctx, 
              function(){
                detect(ctx);
              });
          },
          4000);
      };

      // echo 1-7 > /sys/bus/usb/drivers/usb/unbind
      
      main = function(){
        var video = document.getElementById('video');
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');	
        
        resize();
        
        navigator.getUserMedia = navigator.getUserMedia ||
          navigator.webkitGetUserMedia ||
          navigator.mozGetUserMedia;      
        
        navigator.getUserMedia({
          video: true
        }, function(stream) {
          try {
            video.src = window.URL.createObjectURL(stream);
          } catch (err) {
            video.src = stream;
          }
        }, function() {
          throw Error('Cannot capture user camera.');
        });
        
        console.log(ctx);
        // snapAndDetect(ctx);

        calibrate(
          video, ctx,
          function(){
            console.log(ctx);
            snapAndDetect(ctx);
          });
      };
      
      (function() {
        main();
      }()        
      );
    </script>
    
  </body>
</html>
